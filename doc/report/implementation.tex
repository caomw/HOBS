\section{Implementation}
\label{sec:implementation}

In this section, we detail our implementation on Arduino \cite{Arduino} platform. The whole system is comprised of a glass module, numbers of clients, and a gateway, as shown in the architecture figure (Fig.\,\ref{fig:sysarch}) in last section. We will start from the clients, whose primary tasks are to interface between the Glass and the devices that are attached to it. Then we move on to the implementation of the Glass, who manges users' gesture recognition and communication with clients. The functionality in gateway so far is only minimum to communicate with clients, since it's not the primary focus of this project.

\subsection{Clients}
The clients are comprised of a main Arduino board, an IR receiver, an XBee radio, and various actuators. We used Arduino Uno, which has an ATmega328 microcontroller and suffice our purpose in this project. We use off-the-shell IR receivers ({\color{red} confirm it is PNA4602}), which outputs 0V (low) on detection of 38 KHz carrier or 5V (high) otherwise. The XBee radio, accompanied with an XBee modems, takes charge of the communication with the Glass. Additional components are subject to the device being attached to. In our current system, we have a relay ({\color{red} need to know relay model}) which can control the AC power plug, and we have a USB connected computer to control video playing.

The main function of the client is to respond IR signal, and communicate with the Glass to receive corresponding commands. Normally, the client lives in {\it IDLE} mode. When they receive IR signals, indicating the user is expressing interest in interacting with it, the client responds with an XBee acknowledgement and goes into {\it PENDING} state. In this case, since the client doesn't know how many other clients have also responded to the glass, it will wait until a connection signal. If there are multiple clients waiting to be verified by the Glass, the coordination is done at the Glass through sending the right verifying message. To provide visual feedback to the user, the active client that is being verified will blink faster. When it receives the connecting message, it goes to {\it CONNECTED} state and is now ready to take commands. To summarize the clients' behavior, we have a state machine in Fig.\,\ref{fig:clientFSM} for illustration.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{../figs/clientFSM.pdf}
  \caption{FSM model for client. For each transition, ``e'' stands for event, and ``a'' stands for action}
  \label{fig:clientFSM}
\end{figure}

Within {\it CONNECTED} state, the clients will react differently according to the device it is connected to. In our prototype, we have two different types of devices. The first is a relay, which can control the whole AC power supply. The interface to relay is simply an digital pin. We only need to set it to {\it LOW} or {\it HIGH}. Such command is transmitted remotely from the Glass through XBee using encoded packet. The second tyep is a computer that is used to play video. To send command to the computer, we have a USB adaptor and a python script taking charge of the translation. We use {\it pyserial} and {\it appscript} in the software. And this enables controlling the play and pause of an video, and system-wide volume control.

{\color{red} I arrived here for the second pass - Ben}

\subsection{Glass}
\label{sec:glass}

The Glass is complicated in two folds. First, we move the complexity of coordinating all clients to the Glass. Second, we have to handle user gesture on Glass. For a clean design, we separate the gesture detection and XBee transmission into two customized library, and only expose interesting information to the main program.

The whole work flow is as follows. When the user hasn't shown any interest of interaction, the system lives in {\it IDLE} state. When ``tap'' is detected, the Glass will broadcast IR signal to inform the devices which is in front of the user (the one that can receive IR signal). Then the Glass waits for a specific period of time for acknowledge message sent by clients. The timer in {\it WAIT} state now is set to 1 second. When timer expires, Glass will go to {\it IDLE} if no client has responded, or {\it CONFIRM} if it receives just one message. However, the complicated case is when there are multiple clients that have received IR signal and responded. Though we expect such scenario is rare, there is still chance that the physical devices are put together and it is necessary to differentiate them. In this case, the system goes to {\it VERIFY} state, and send out corresponding verifying message based on user's gesture. Once the user confirmed the selection, it goes to {\it CONNECTED} state where it's ready to send out commands. Again, to illustrate the flows, we have the FSM in Fig.\,\ref{fig:glassFSM}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{../figs/glassFSM.pdf}
  \caption{FSM model for Glass. For each transition, ``e'' stands for event, and ``a'' stands for action}
  \label{fig:glassFSM}
\end{figure}

\subsection{Gateway}
\label{sec:gateway}

The gateway provides access to the personal area network for computers, and presumably this can be further open to the Internet. Since there have already been many products \cite{NinjaBlocks, Lockitron} that essentially function in this way, we do not spend much time on this aspect in our project. 

Just for completeness, we wrote a python script that controls a USB XBee adaptor, so that we can remotely control those devices without the Glass and IR initiation.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
